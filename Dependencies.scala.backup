package langdb.ast

case class NameInfo(
  name: String,
  bindingLocation: Option[Term], // Where this name is bound (Lambda param or Let binding)
  references: List[Term]         // All places where this name is referenced
)

case class DependencyGraph(
  bindings: Map[String, NameInfo],
  freeVariables: Set[String]     // Variables that are referenced but not bound
):
  def addBinding(name: String, bindingTerm: Term): DependencyGraph =
    val updated = bindings.get(name) match
      case Some(existing) => existing.copy(bindingLocation = Some(bindingTerm))
      case None => NameInfo(name, Some(bindingTerm), List.empty)
    copy(bindings = bindings + (name -> updated))
  
  def addReference(name: String, referenceTerm: Term): DependencyGraph =
    val updated = bindings.get(name) match
      case Some(existing) => existing.copy(references = referenceTerm :: existing.references)
      case None => NameInfo(name, None, List(referenceTerm))
    
    val newBindings = bindings + (name -> updated)
    val newFreeVars = if (updated.bindingLocation.isEmpty) freeVariables + name else freeVariables
    
    copy(bindings = newBindings, freeVariables = newFreeVars)

object DependencyAnalyzer:
  
  def analyze(term: Term): DependencyGraph =
    analyzeWithContext(term, Set.empty, DependencyGraph(Map.empty, Set.empty))
  
  private def analyzeWithContext(
    term: Term, 
    boundVars: Set[String], 
    graph: DependencyGraph
  ): DependencyGraph =
    term match
      case Term.Var(name) =>
        // This is a variable reference
        graph.addReference(name, term)
      
      case Term.Lambda(param, _, body) =>
        // Lambda introduces a new binding for param
        val newBoundVars = boundVars + param
        val graphWithBinding = graph.addBinding(param, term)
        analyzeWithContext(body, newBoundVars, graphWithBinding)
      
      case Term.App(func, arg) =>
        // Application: analyze both function and argument
        val graphAfterFunc = analyzeWithContext(func, boundVars, graph)
        analyzeWithContext(arg, boundVars, graphAfterFunc)
      
      case Term.Let(name, value, body) =>
        // Let binding: analyze value first, then add binding, then analyze body
        val graphAfterValue = analyzeWithContext(value, boundVars, graph)
        val graphWithBinding = graphAfterValue.addBinding(name, term)
        val newBoundVars = boundVars + name
        analyzeWithContext(body, newBoundVars, graphWithBinding)
      
      case Term.Add(left, right) =>
        val graphAfterLeft = analyzeWithContext(left, boundVars, graph)
        analyzeWithContext(right, boundVars, graphAfterLeft)
      
      case Term.Eq(left, right) =>
        val graphAfterLeft = analyzeWithContext(left, boundVars, graph)
        analyzeWithContext(right, boundVars, graphAfterLeft)
      
      case Term.If(condition, thenBranch, elseBranch) =>
        val graphAfterCond = analyzeWithContext(condition, boundVars, graph)
        val graphAfterThen = analyzeWithContext(thenBranch, boundVars, graphAfterCond)
        analyzeWithContext(elseBranch, boundVars, graphAfterThen)
      
      case _: Term.IntLit | _: Term.StringLit | _: Term.BoolLit =>
        // Literals don't introduce dependencies
        graph
